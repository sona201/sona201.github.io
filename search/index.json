[{"content":"方法论：通过拆解马拉松，深刻领会阶梯原理 原文链接\n原文摘要 你一定知道那个日本的马拉松冠军选手——山田本一。山田本一获得多个国际马拉松赛事冠军后，退役，并揭秘了自己的夺冠技巧。\n那就是，在每次马拉松比赛前，他都要驱车把比赛路程提前走一遍。然后，他把整个比赛路段，分成若干段，分别以各种标志建筑物、地貌特征为标记。\n正式比赛时，山田本一就会只考虑当前这一段路怎么跑，然后全力以赴完成这一段赛程。当一段赛程完成后，他就又会全力以赴地完成下一个赛段。\n看到这里，我以为，跑马拉松，只要把整个赛段分解成多个赛段，问题就解决了。就好像做学习或工作计划，只要把学习或工作任务，按照时间，分配好进度就能做好。\n可事实却打了我的脸。\n我的学习计划，工作计划，都不能按期完成，看来拆解目标，可不只是分段、分时、分任务，应该设立进阶条件。\n使用阶梯原理的关键，就是如何合理地拆解目标，山田本一的拆解，只是调整了我们实现目标时的心态，那就是心无旁骛，全力以赴做好当前的任务。 而真正合理有效的目标拆解，一定要多设立几个中间标准，并且，你需要先完成前一个，再去进阶下一个目标。\n我的思考 学习是一件需要终生持续的事情，因此我总是认为只要我学习了就没有\u0026quot;浪费生命\u0026quot;，为此我陷入每天都要学习的\u0026quot;自我感动\u0026quot;中，不去考虑学习的效率。 毕竟再笨也会偶尔全身心投入到学习中，并且能从中感受到快乐，也许那就是\u0026quot;内啡肽\u0026quot;。\n我对学习效率要求很低，或者很少考虑这项指标，更多的是凭感觉做事。 毕竟这个指标的考量难度和维度都比较复杂，不像从学习时间这个维度参考。甚至学习时间还有水分，愣神，玩手机偶尔也会被归算到学习时间内。 对自己学习的计算没有办法能真正精确，还有就是人性，总是美化自己，眼睛会自动给自己的外貌进行美化，也会美化自己的学习能力，记忆力等等。\n参考山田本一的马拉松阶梯原理: 小步子原理，也叫阶梯原理，心理学上也叫里程碑效应。\n他的诀窍: 那就是，在每次马拉松比赛前，他都要驱车把比赛路程提前走一遍。然后，他把整个比赛路段，分成若干段，分别以各种标志建筑物、地貌特征为标记。\n一、熟悉整个流程 跟了解马拉松比赛路程一样，学习一个知识需要知道学会哪些东西才能叫入门，知道整个比赛路程，就会对学习的知识任务量有概念。\n我总是一股脑找一堆学习方法论，学习资料，文章、书籍、视频。然后想当然的对自己说，坚持看完就会了。\n比如学习java，想当然的认为跟着廖雪峰的java资料后面敲一遍代码就会了。事实是，看了两篇文章后就一直停止在那一章节。 我对学会java没有一个概念，不知道怎样才叫入门，把别人的目标直接拿过来，没仔细想过这个是不是自己的目标，当前的教程内容合不合适我， 是偷懒认为跟着别人的教程就会了。\n这种情况生活中太多了，买了书(资料)认为就是学会了，收藏锻炼视频就是锻炼了。\n二、设立目标 都知道需要设立目标，我平时也没少给自己设目标，甚至会对身边的人说出来，让身边的来一起督促自己，最后结果是周围的人也知道我喜欢乱立Flag了。\n上面说的是一个典型的问题，设目标，但是目标其实不清晰，跟第一点有关联，但不全一样。\n偶尔会出现我确实立了一个明确的目标，例如看java学习视频，一共大概128个视频，计划一个月学完，然后一个除法，128/30=4.2。拍脑袋决定一天看5个视频。前期看的时候发现还行，每个视频的时间在13分钟左右，每天看完大概要一个小时。但后来就坚持不下去了。\n并不能保证每天能抽空出1个多小时，碰到加班或者家庭活动，几乎完全抽不出时间来学习。 前期的介绍类的视频，一个视频只有10分钟，但后期详情视频一个大约30分钟，要按计划的话，2.5小时。远超计划。 因为对学习内容的不熟悉，看视频会停下来思考，或者跟着敲代码，即使是1个小时的视频，加上理解可能会时间翻倍。 要做出合理的计划，总之不能拍脑袋定了目标后，完成不了就放弃，需要动态更新计划，而不是拖延跟放弃。\n目标内容合理，慢就慢点，每天一共2个小时的学习时间应该算是一种极限。 目标清晰，看视频或文章，如果没有自己的思考等于白看，甚至记录笔记但转头就忘也是需要改进的。 比如想自己写个博客主题，这个目标就不清晰，怎么做，做成什么样子都是空的。 做这个主题要多久，没有一个考量，一个任务(task)的时间大概控制在1小时左右 认识到自己的精力是有限的，不能总是在理想情况下做计划，满负荷学习(工作)，总会遇到问题，需要劳逸结合 三、冷启动，坚持 学习一个新的知识一般都会很容易产生新奇感，但要是遇到难点，总是解决不了，大概率就是放弃。\n因为这个问题经常困扰我，可能我以前解决过这个情况，但没有形成一套方法论，这里先推出一个想法: 继续学习，挑有成就感的知识点学习。 总之需要先继续学习，遇到难题记录下来，然后继续学习。本身学习也是需要通过笔记来复习巩固，记忆力再好还是不如笔记来的实在。 而且能通过复习笔记发现之前的问题。\n坚持学下去，但不要每次都是从0开始，就想高中被英语单词，最熟悉的第一页，项目是要有推进的。\n四、设立奖励 与上面讲的劳逸结合一个意思，人不是机器，不可能总是高强度满负荷学习，需要给自己主动休息的时间。\n主动休息也是一种给自己一个信号，我休息了，而不是自己陷入不想开始学习的状态，不停的刷小视频，玩2-3小时，最后人更累。 主动玩游戏，看看动漫视频，做点与学习无关自己喜欢的事情，让大脑接受到\u0026quot;我正在休息\u0026quot;的信号，也是给自己奖励，建立一个正向反馈机制。\n五、优先级 四象限法，一个老生常谈的方式，但实际情况是我们不能分清哪些事情优先级高，需要多思考。\n当然前面也提到，设立了阶段目标后，只需要心无旁骛，全力以赴\n","date":"2023-07-16T11:15:33+08:00","permalink":"https://sona201.github.io/posts/study_think/","title":"Study_think"},{"content":"排查python server当时的系统信息 发现并没有异常，仅记录device eth0 entered promiscuous mode表示当时网卡 eth0 进入混杂模式,应该与当时启用tcpdump有关。\n一、将python server改为nginx server方式，测试下载有没有异常 1 2 3 4 5 6 7 8 [root@172.19.9.147 ~]# curl -O http://172.19.5.43/404.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3650 100 3650 0 0 2313k 0 --:--:-- --:--:-- --:--:-- 3564k [root@172.19.9.147 ~]# curl -O http://172.19.5.43/zookeeper.out % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 1880M 100 1880M 0 0 396M 0 0:00:04 0:00:04 --:--:-- 396M 一切正常\n二、服务端参数修改异常参数测试 使用nginx server，设置成net.ipv4.tcp_wmem=\u0026quot;4096 4096 4096\u0026quot;\n顺便记录下nginx配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 80; listen [::]:80; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 2.1 测试改为异常数据时，能否同时下载别的文件，排除线程卡死原因 命令行窗口1 1 2 3 4 [root@172.19.9.147 ~]# curl -O http://172.19.5.43/zookeeper.out % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:13 --:--:-- 0 命令行窗口2 1 2 3 4 5 6 7 8 9 10 11 12 [root@172.19.9.147 ~]# curl -O http://172.19.5.43/404.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3650 100 3650 0 0 2676k 0 --:--:-- --:--:-- --:--:-- 3564k [root@172.19.9.147 ~]# curl -O http://172.19.5.43/zookeeper.out % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:01:00 --:--:-- 0^C [root@172.19.9.147 ~]# curl -O http://172.19.5.43/404.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3650 100 3650 0 0 2664k 0 --:--:-- --:--:-- --:--:-- 3564k 2.2 测试改为异常数据的临界值，使用二分法测试 1 2 3 4 5 6 7 8 9 10 11 [root@172.19.5.43 html]# sysctl -w net.ipv4.tcp_wmem=\u0026#34;4096 4096 9000\u0026#34; net.ipv4.tcp_wmem = 4096 4096 9000 # 这个可以正常下载 [root@172.19.5.43 html]# sysctl -w net.ipv4.tcp_wmem=\u0026#34;4096 4096 8259\u0026#34; net.ipv4.tcp_wmem = 4096 4096 8259 # 这个可以正常下载 [root@172.19.5.43 html]# sysctl -w net.ipv4.tcp_wmem=\u0026#34;4096 4096 8257\u0026#34; net.ipv4.tcp_wmem = 4096 4096 8257 [root@172.19.5.43 html]# sysctl -w net.ipv4.tcp_wmem=\u0026#34;4096 4096 8258\u0026#34; net.ipv4.tcp_wmem = 4096 4096 8258 # 这个不能下载 结论：参数配置再 net.ipv4.tcp_wmem=\u0026quot;4096 4096 8258\u0026quot; 及以下不能正常请求\n三、排除文件原因，使用dd生成2G文件 设置为sysctl -w net.ipv4.tcp_wmem=\u0026quot;4096 4096 4096\u0026quot;,大文件确实会被卡住，小文件不受影响。\n用dd if=/dev/zero of=large_file bs=1G count=2生成的文件2G大小文件。\n命令行窗口1 1 2 3 4 [root@172.19.9.147 ~]# curl -O http://172.19.5.43/large_file % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:04 --:--:-- 0 命令行窗口2 1 2 3 4 [root@172.19.9.147 ~]# curl -O http://172.19.5.43/404.html % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3650 100 3650 0 0 2905k 0 --:--:-- --:--:-- --:--:-- 3564k 同样，换成 large_file 文件一样不能下载。得出结果与之前文件一致：\n临界值就是在net.ipv4.tcp_wmem = 4096 4096 8259 下载大文件卡住时，同时下载小文件不受影响。 四、确认内核版本 当前是用的linux版本内核为\n1 2 [root@172.19.5.43 html]# uname -a Linux 172.19.5.43 3.10.0-957.27.2.el7.x86_64 #1 SMP Mon Jul 29 17:46:05 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux ","date":"2023-05-19T01:05:14+08:00","permalink":"https://sona201.github.io/posts/tc_%E5%AE%9E%E9%AA%8C/","title":"Tc_实验"},{"content":"相关文章\n方案: 手动启动浏览器，让浏览器把证书放到指定目录，wireshark去读取，然后解析，就可以得到解密后的包了，等同于http请求抓包\n一、启动浏览器 在终端执行命令，打开新的 Chrome 浏览器\n1 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --user-data-dir=/tmp/chrome --ssl-key-log-file=/tmp/.ssl-key.log 二、配置wireshark 1 打开 Wireshark ，Wireshark - Perferences - Protocols - TLS ，在 (Pre)-Master-Secret log filename 输入 /tmp/.ssl-key.log 三、抓包 打开浏览器，发出请求，开始抓包 四、异常情况 异常情况暂未遇到过，这个先记录一下\n出现 Opening in existing browser session. 解决方式：关闭掉用命令启动的 Chrome，然后重新运行 Chrome 启动命令\n1 2 $ ps -ef | grep /tmp/.ssl | awk \u0026#39;NR==1{print $2}\u0026#39; | xargs kill -9 $ /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --user-data-dir=/tmp/chrome --ssl-key-log-file=/tmp/.ssl-key.log 参考文章 使用wireshark分析https\n","date":"2023-05-19T01:05:14+08:00","permalink":"https://sona201.github.io/posts/wireshark%E6%9C%AC%E5%9C%B0%E5%8A%AB%E6%8C%81https/","title":"Wireshark本地劫持https"},{"content":"相关文章\nwireshark你一定会喜欢的技巧摘要\n修改seq的为绝对值 relative 配置rt 分析 分析图\nwireshark https 抓包 tls contains \u0026ldquo;baidu.com\u0026rdquo;\nwireshark 没有权限 或者下图\n命令行赋权\n直接简单粗暴的777 1 sudo chmod 777 /dev/bpf* 查看当前用户名，给当前用户赋权 1 sudo chown clin:wheel /dev/bpf* 本来这个命令都不打算记录，但最近在自己电脑上重新安装就出现一次，还是老老实实的记录下\n一、抓包 拿到一个网络包时，我们总是希望它尽可能小。因为操作一个大包相当费时，有时甚至会死机。如果让初学者分析1GB以上的包，估计会被打击得信心全无。所以抓包时应该尽量只抓必要的部分。有很多方法可以实现这一点。\n1．只抓包头。一般能抓到的每个包（称为“帧”更准确，但是出于表达习惯，本书可能会经常用“包”代替“帧”和“分段”）的最大长度为1514字节，启用了Jumbo Frame（巨型帧）之后可达9000字节以上，而大多数时候我们只需要IP头或者TCP头就足够分析了。在Wireshark上可以这样抓到包头：单击菜单栏上的Capture\u0026ndash;\u0026gt;Options，然后在弹出的窗口上定义“Limit each packet to”的值。我一般设个偏大的数字：80字节，也就是说每个包只抓前80字节。这样TCP层、网络层和数据链路层的信息都可以包括在内（见图1）。\n3.0之前版本wireshark更改方式\n图一\n3.0之后的版本\n如果问题涉及应用层，就应该再加上应用层协议头的长度。如果你像我一样经常忘记不同协议头的长度，可以输入一个大点的值。即便设成200字节，也比1514字节小多了。\n以上是使用Wireshark抓包时的建议。用tcpdump命令抓包时可以用“-s”参数达到相同效果。比如以下命令只抓eth0上每个包的前80字节，并把结果存到/tmp/tcpdump.cap文件中。\n使用tcpdump指定抓包字节命令\n1 [root@server_1 /]# tcpdump -i eth0 -s 80 -w /tmp/tcpdump.cap 2．只抓必要的包。服务器上的网络连接可能非常多，而我们只需要其中的一小部分。Wireshark的Capture Filter可以在抓包时过滤掉不需要的包。比如在成百上千的网络连接中，我们只对IP为10.32.200.131的包感兴趣，那就可以在Wireshark上这样设置：单击菜单栏上的Capture\u0026ndash;\u0026gt;Options，然后在Capture Filter中输入“host 10.32.200.131”（见图2）。\n老版本\n图二\nVersion 4.0.5版本\nwireshark官方的过滤文档 用tcpdump命令抓包时，也可以用“host”参数达到相同效果。比如以下命令只抓与10.32.200.131通信的包，并把结果存到/tmp/tcpdump.cap文件中。\n1 [root@server_1 /]# tcpdump -i eth0 host 10.32.200.131 -w /tmp/tcpdump.cap 注意：设置Capture Filter之前务必三思，以免把有用的包也过滤掉，尤其是容易被忽略的广播包。当然有时候再怎么考虑也会失算，比如我有一次把对方的IP地址设为filter，结果一个包都没抓到。最后只能去掉filter再抓，才发现是NAT（网络地址转换）设备把对方的IP地址改掉了。 抓的包除了要小，最好还能为每步操作打上标记。这样的包一目了然，赏心悦目。比如要在Windows上抓一个包含三步操作的问题，我会这样抓。\n想指定ping，发送三次包，每次只发送一个ping包(count)，不通次数发送的ping的size大小不一样，\nwindows机器指定ping方式\n1 2 3 4 5 6 （1）ping \u0026lt;IP\u0026gt; -n 1 -l 1 （2）操作步骤1 （3）ping \u0026lt;IP\u0026gt; -n 1 -l 2 （4）操作步骤2 （5）ping \u0026lt;IP\u0026gt; -n 1 -l 3 （6）操作步骤3 windows ping命令解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name 选项: -t Ping 指定的主机，直到停止。 若要查看统计信息并继续操作，请键入 Ctrl+Break； 若要停止，请键入 Ctrl+C。 -a 将地址解析为主机名。 -n count 要发送的回显请求数。 -l size 发送缓冲区大小。 -f 在数据包中设置“不分段”标记(仅适用于 IPv4)。 -i TTL 生存时间。 -v TOS 服务类型(仅适用于 IPv4。该设置已被弃用， 对 IP 标头中的服务类型字段没有任何 影响)。 -r count 记录计数跃点的路由(仅适用于 IPv4)。 -s count 计数跃点的时间戳(仅适用于 IPv4)。 -j host-list 与主机列表一起使用的松散源路由(仅适用于 IPv4)。 -k host-list 与主机列表一起使用的严格源路由(仅适用于 IPv4)。 -w timeout 等待每次回复的超时时间(毫秒)。 -R 同样使用路由标头测试反向路由(仅适用于 IPv6)。 根据 RFC 5095，已弃用此路由标头。 如果使用此标头，某些系统可能丢弃 回显请求。 -S srcaddr 要使用的源地址。 -c compartment 路由隔离舱标识符。 -p Ping Hyper-V 网络虚拟化提供程序地址。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 mac/linux ping命令执行\n1 2 3 4 5 6 ping \u0026lt;IP\u0026gt; -c 1 -s 1 操作步骤1 ping \u0026lt;IP\u0026gt; -c 1 -s 2 操作步骤2 ping \u0026lt;IP\u0026gt; -c 1 -s 3 操作步骤3 这个抓包在mac上命令方式不一样，导致我一直没有执行成功\n如图3所示，如果我需要分析步骤1，则只要看146～183之间的包即可。注意到146号包最底下的“Data（1 byte）”了吗？byte的数目表示是第几步，这样就算在步骤很多的情况下也不会混乱。 抓包的技巧还有很多，比如可以写一个脚本来循环抓包，等侦察到某事件时自动停止。一位工程师即便不懂网络分析，但如果能抓得一手好包，也是一项很了不起的技能了。\n二、个性化设置 Wireshark的默认设置堪称友好，但不同用户的从事领域和使用习惯各有不同，所以有时需要根据自己的情况对配置略作修改。\n1．我经常需要参照服务器上的日志时间，找到发生问题时的网络包。所以就把Wireshark的时间调成跟服务器一样的格式。单击Wireshark的View\u0026ndash;\u0026gt;Time Display Format\u0026ndash;\u0026gt;Date and Time of Day，就可以实现此设置（见图4）。\n图四\nVersion 4.0.5版本设置\n2．不同类型的网络包可以自定义颜色，比如网络管理员可能会把OSPF等协议或者与Spanning Tree Protocol（生成树协议）相关的网络包设成最显眼的颜色。而文件服务器的管理员则更关心FTP、SMB和NFS协议的颜色。我们可以通过View \u0026ndash;\u0026gt;Coloring Rules来设置颜色。如果同事已经有一套非常适合你工作内容的配色方案，可以请他从Coloring Rules窗口导出，然后导入到你的Wireshark里（见图5）。记得下次和他吃饭时主动买单，要知道配一套养眼的颜色可要花不少时间。\n图五\nVersion 4.0.5版本的样式\n3．更多的设置可以在Edit\u0026ndash;\u0026gt;Preferences窗口中完成。这个窗口的设置精度可以达到一些协议的细节。比如在此窗口单击Protocols\u0026ndash;\u0026gt;TCP就可以看到多个TCP相关选项，将鼠标停在每一项上都会有详细介绍。假如经常要对Sequence Number做加减运算，不妨选中Relative sequence numbers（见图6），这样会使Sequence number看上去比实际小很多。\nVersion 4.0.5版本的样式\n4．如果你在其他时区的服务器上抓包，然后下载到自己的电脑上分析，最好把自己电脑的时区设成跟抓包的服务器一样。这样，Wireshark显示的时间才能匹配服务器上日志的时间。比如说，服务器的日志显示2/13/2014 13:01:32有一个错误信息。那我们要在自己电脑上调整时区之后，才能到Wireshark上检查2/13/2014 13:01:32左右的包，否则就得先换算时间。\n三、过滤 很多时候，解决问题的过程就是层层过滤，直至找到关键包。前面已经介绍过抓包时的Capture Filter功能了。其实在包抓下来之后，还可以进一步过滤，而且这一层的过滤功能更加强大。下图表示一个\u0026quot;IP为10.32.106.50，且TCP端口为445\u0026quot;的过滤表达式。\nVersion 4.0.5版本的样式\n要说过滤的作用与技巧，就算专门写一本小册子都不为过。篇幅所限，本文只能\u0026quot;过滤\u0026quot;出最适合初学者的部分。\n1．如果已知某个协议发生问题，可以用协议名称过滤一下。以Windows Domain的身份验证问题为例，如果已知该域的验证协议是Kerberos，那么就在Filter框输入Kerberos作为关键字过滤。除了纯粹的Kerberos包，你还将得到Session Setup之类包含Kerberos的包。\n用协议过滤时务必考虑到协议间的依赖性。比如NFS共享挂载失败，问题可能发生在挂载时所用的mount协议，也可能发生在mount之前的portmap协议。这种情况下就需要用\u0026quot;portmap || mount\u0026quot;来过滤了。如果不懂协议间的依赖关系怎么办？我也没有好办法，只能暂时放弃这个技巧，等熟悉了该协议后再用。\n2．IP地址加port号是最常用的过滤方式。除了手工输入ip.addreq \u0026amp;\u0026amp;tcp.porteq\u0026lt;端口号\u0026gt;之类的过滤表达式，Wireshark还提供了更快捷的方式：右键单击感兴趣的包，选择Follow TCP/UDP Stream（选择TCP还是UDP要视传输层协议而定）就可以自动过滤。而且该Stream的对话内容会在新弹出的窗口中显示出来。\nVersion 4.0.5版本的样式\n经常有人在论坛上问，Wireshark是按照什么过滤出一个TCP/UDP Stream的？答案就是：两端的IP加port。单击Wireshark的Statistics\u0026ndash;\u0026gt;Conversations，再单击TCP或者UDP标签就可以看到所有的Stream。\nVersion 4.0.5版本的样式\n3．用鼠标帮助过滤。我们有时因为Wireshark而苦恼，并不是因为它功能不够，而是强大到难以驾驭。比如在过滤时，有成千上万的条件可供选择，但怎么写才是合乎语法的？虽然 http://www.wireshark.org/docs/dfref/ 提供了参考，但经常查找毕竟太费时费力了。Wireshark考虑到了这个需求，右键单击Wireshark上感兴趣的内容，然后选择Prepare a Filter\u0026ndash;\u0026gt;Selected，就会在Filter框中自动生成过滤表达式。在有复杂需求的时候，还可以选择And、Or等选项来生成一个组合的过滤表达式。\n假如右键单击之后选择的不是Prepare a Filter，而是Apply as Filter\u0026ndash;\u0026gt;Selected，则该过滤表达式生成之后还会自动执行。图12显示了在一个SMB包的SMB Command: Read AndX上右键单击，并选择Selected之后，所有的Read包都会被过滤出来。\nVersion 4.0.5版本的样式\n4．我们可以把过滤后得到的网络包存在一个新的文件里，因为小文件更方便操作。单击Wireshark的File\u0026ndash;\u0026gt;Save As，选中Displayed单选按钮再保存，得到的新文件就是过滤后的部分。\n有时候你会发现，保存后的文件再打开时会显示很多错误。这是因为过滤后得到的不再是一个完整的TCP Stream，就像抓包时漏抓了很多一样。所以选择Displayed选项时要慎重考虑。\n注意：有些Wireshark版本把这个功能移到了菜单File\u0026ndash;\u0026gt;Export Specified Packets…选项中，如下图所示。\nVersion 4.0.5版本的样式\n总体来说，过滤是Wireshark中最有趣，最难，也是最有价值之处，值得我们用心学习。\n四、让Wireshark自动分析 有些类型的问题，我们根本不需要研究包里的细节，直接交给Wireshark分析就行了。\n1．单击Wireshark的Analyze\u0026ndash;\u0026gt;Expert Info Composite，就可以在不同标签下看到不同级别的提示信息。比如重传的统计、连接的建立和重置统计，等等。在分析网络性能和连接问题时，我们经常需要借助这个功能。下图是TCP包的重传统计。\nVersion 4.0.5版本的样式\n2．单击Statistics\u0026ndash;\u0026gt;Service Response Time，再选定协议名称，可以得到响应时间的统计表。我们在衡量服务器性能时经常需要此统计结果。图16展示的是SMB2读写操作的响应时间。\n4.0.5版本的协议很少，甚至没有看到tcp协议，把所有协议看了，只有NCP、SMB两种协议有内容，内容不像分析数据。\n3．单击Statistics\u0026ndash;\u0026gt;TCP Stream Graph，可以生成几类统计图。比如我曾经用Time-Sequence Graph (Stevens)生成了下图。\nVersion 4.0.5版本的样式\n从老图中可以看出25～40秒，以及65～75秒之间没有传输数据。进一步研究，发现发送方内存不足，所以偶尔出现暂停现象，添加内存后问题就解决了。\n为什么Wireshark要把这个图称为“Stevens”呢？我猜是为了向《TCP/IP Illustrated》的作者Richard Stevens致敬。这也是我非常喜欢的一套书，在此推荐给所有读者。\n4．单击Statistics\u0026ndash;\u0026gt;Summary，可以看到一些统计信息，比如平均流量等，这有助于我们推测负载状况。比如下图中的网络包才1.594Mbit/s，说明流量低得很。\nVersion 4.0.5版本没有找到 Statistics\u0026ndash;\u0026gt;Summary 选项，但找到 Statistics\u0026ndash;\u0026gt;Conversations(对话)，但看起来结果差不多\nVersion 4.0.5版本没有找到 Statistics\u0026ndash;\u0026gt;Summary 选项，但找到 Statistics\u0026ndash;\u0026gt;Capture File Properties，菜单改了\n参考最新菜单解释https://www.wireshark.org/docs/wsug_html_chunked/ChUseStatisticsMenuSection.html\n五、最容易上手的搜索功能 与很多软件一样，Wireshark也可以通过“Ctrl+F”搜索关键字。假如我们怀疑包里含有“error”一词，就可以按下“Ctrl+F”之后选中“String”单选按钮，然后在Filter中输入“error”进行搜索。很多应用层的错误都可以靠这个方法锁定问题包。\n一篇文章不可能涵盖所有技巧，本文就到此为止。最后要分享的，是我认为最“笨”但也是最重要的一个技巧——勤加练习。只要练到这些技巧都变成习惯，就可以算登堂入室了。\n","date":"2023-05-19T01:05:14+08:00","permalink":"https://sona201.github.io/posts/wireshark%E6%8A%80%E5%B7%A7/","title":"Wireshark技巧"},{"content":"我是2014年毕业，去过工地，干过销售。16年，我妈查出胃癌早期，一年后，她身体差不多康复，于是我决定出去闯闯。\n其实也算不上闯，只是听起来好听而已。在大学的时候，我学的是电气工程及其自动化，一个跟计算机几乎没有关系的专业。对口工作就是水电工，或者去供电局。但我其实小时候就对计算机感兴趣，高考填志愿的时候，我想选计算机，结果家里没同意，怕找不到工作。我也没有跟家里犟，毕竟我也不知道未来啥样。大学也会看看相关的消息，拿的出手的事就是用自己电脑安装了双系统，win7/ubuntu。2017年，我拿出4000块报名了一个运维线上培训班，其实15年就想报名了，但没有下定决心，担心自己做不好等等。16年照顾我妈身体的时候，买了本《鸟哥的私房菜》。然后就慢慢开始了我的IT路。\n17好不容易找了一家公司要我，毕竟培训班出来的，水平菜的不像话。那段时间疯狂学习，接触到了coolshell.cn，发现这个人好厉害，怎么会这么多东西，关键是这些东西都学的很深。夸张点讲，每个名词都我要去百度查询下。在推上看到好多人都说被陈皓帮助过，感叹我怎么还没能成长起来。年龄也不小了。\n当时特别沉迷他的博客，虽然没有看完所有，但真的好多对我帮助很大。找到当时一篇文章陈皓的经历，下午与同事聊天说到他这段故事，还是感叹他厉害。不过这会儿又翻了好多他的博客，心里有点欣慰，还是有很多宝藏在的，只是我之前不珍惜。总感觉没有人给我指路。也是他的数字遗产，珍惜。\n想想他 5/1 发的推文，将他爸爸每天发送平安。\n第一次意识到死亡\n小时候，大概是10岁左右，上上上辈儿的老人相继离世，那个时候还不太明白生命的意义，直到某次参加葬礼，在火葬场差点丢了，没找到回去灵车，感觉是不是那天没人找我，是不是要死在那里了，没人认识我。后来我经常熬夜，上床后听到自己心跳声很大，担心突然猝死。小时候也梦到过自己死亡。\n同龄人离世\n上高一时，一个同年级的孩子突然睡梦中离世，听说学校的处理方式就是把几个同宿舍的孩子换个寝室。那阵子，税前也总是担心看不到明天的太阳。直到现在，我也是习惯把自己搞的很累，几乎倒床就睡的那种，不然就会疯狂玩手机。睡前胡思乱想已经是常态。\n同龄人离死亡最近的时候。\n朋友2019年去医院看病，当时是肚子不舒服，在上海瑞金医院看病，大概是做了常规检查:心电图，然后就被医生叫住，直接送进重症病房，甚至他手里还拎着肚子疼开的药。电话联系家属，告知以后不能喝酒等，注意饮食。不能过量运动。后来他出院，我打电话听到消息，那个周末去找他，跟我说着说着就哭了，担心白发人送黑发人。那段时间，我真的有在想自己的健康好不好。\n陈皓的突然离世\n这个是真的意外，总感觉这是命运的玩笑，看到消息第一反应是不是谣言，希望辟谣，但看了推文，甚至还@haoel，太唏嘘了。很多推友在考虑养生，但这个大概率又是3分钟热度吧。最近也是焦虑成性，经常熬夜，到家总是看短视频。陈皓说，短视频最浪费时间，最没营养。今天把微信的短视频入口关了。\n陈皓留的数字文化遗产还挺多的，够学好久了。\nR.I.P(Requiescat in pace)\n关于数字遗产这件事，今天看到laike9m的文章people-die-but-long-live-github，感叹人的第二次消失有时候也挺容易的。\n也同时感慨，人要做什么才会有意义。这个问题需要好好问问自己。想到和菜头的一篇文章，讲一个美国的地勤偷飞机，然后完成了自己的梦想，最后与飞机一起坠毁文章链接，故事在结尾，有时候对别的朋友圈生活嗤之以鼻，但也会羡慕。媳妇儿却很简单，想去尝试下那种生活。今年的计划，去趟香港，开开眼。\n文章链接 infoQ-纪念陈皓（左耳朵耗子） 和菜头-仅有他汀是不够的 laike9m-R.I.P. 陈皓 laixintao-缅怀陈皓\n","date":"2023-05-15T22:33:26+08:00","permalink":"https://sona201.github.io/posts/haoel/","title":"Haoel"},{"content":"MIDDLEWARE/get_response 5.2 django处理http请求源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ) # WSGIRequest对象 -\u0026gt; HttpRequest类 request = self.request_class(environ) # response是什么 response = self.get_response(request) def get_response(self, request): \u0026#34;\u0026#34;\u0026#34;Return an HttpResponse object for the given HttpRequest.\u0026#34;\u0026#34;\u0026#34; # Setup default url resolver for this thread set_urlconf(settings.ROOT_URLCONF) response = self._middleware_chain(request) response._resource_closers.append(request.close) if response.status_code \u0026gt;= 400: log_response( \u0026#34;%s: %s\u0026#34;, response.reason_phrase, request.path, response=response, request=request, ) return response 研究 django.http.request.py 研究 django.http.response.py self._middleware_chain(request) 他的上一步是 self.load_middleware() 在实例化 WSGIHandler 的时候就有 self.load_middleware()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware() def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ) # WSGIRequest对象 -\u0026gt; HttpRequest类 request = self.request_class(environ) # response是什么 response = self.get_response(request) 研究url 分发\n1 set_urlconf(settings.ROOT_URLCONF) 大的议题\nrequest response callback, callback_args, callback_kwargs = self.resolve_request(request) 视图层的问题, as_view 1 2 3 4 5 6 7 8 9 MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # 初始化中间件进行层层包裹 self.load_middleware() # 将 settings.MIDDLEWARE # reversed # import_string # handler \u0026lt;-\u0026gt; self._get_response 方法 # handler = warp(XFrameOptionsMiddleware(self._get_response)) # handler = warp(MessageMiddleware(XFrameOptionsMiddleware(self._get_response))) # handler() -\u0026gt; 1. MessageMiddleware.process_request() # 2. XFrameOptionsMiddleware.process_request() # 3. self._get_response # 4. XFrameOptionsMiddleware.process_response() # 5. MessageMiddleware.process_response() # # client -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; request # view -\u0026gt; self._get_response # client \u0026lt;- 1 \u0026lt;- 2 \u0026lt;- 3 \u0026lt;- response 1 2 3 4 5 6 7 8 SecurityMiddleware(SessionMiddleware(CommonMiddleware(CsrfViewMiddleware(AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response))))))) SessionMiddleware(CommonMiddleware(CsrfViewMiddleware(AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response)))))) CommonMiddleware(CsrfViewMiddleware(AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response))))) CsrfViewMiddleware(AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response)))) AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response))) MessageMiddleware(XFrameOptionsMiddleware(self._get_response)) XFrameOptionsMiddleware(self._get_response) self._get_response 变成一个链式调用, 请求进来时, 最外层先执行\n请求进来WSGIHandler() 实例化后, 调用 call\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware() def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ) # WSGIRequest对象 -\u0026gt; HttpRequest类 request = self.request_class(environ) # response是什么 response = self.get_response(request) 然后调用\n1 response = self._middleware_chain(request) 会执行调用链 SecurityMiddleware(SessionMiddleware(CommonMiddleware(CsrfViewMiddleware(AuthenticationMiddleware(MessageMiddleware(XFrameOptionsMiddleware(self._get_response)))))))\n因为继承了 MiddlewareMixin, 调用触发 call\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MiddlewareMixin: def __call__(self, request): # Exit out to async mode, if needed if asyncio.iscoroutinefunction(self.get_response): return self.__acall__(request) response = None if hasattr(self, \u0026#34;process_request\u0026#34;): response = self.process_request(request) # 当response 为空时,会执行self.get_response(request), 这个又会调用下一个函数的self.get_response(request),是一个递归 response = response or self.get_response(request) if hasattr(self, \u0026#34;process_response\u0026#34;): response = self.process_response(request, response) return response 会递归执行\n1 response = response or self.get_response(request) 然后才执行\n1 self.process_response(request, response) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class BaseHandler: _view_middleware = None _template_response_middleware = None _exception_middleware = None _middleware_chain = None def _get_response(self, request): \u0026#34;\u0026#34;\u0026#34; Resolve and call the view, then apply view, exception, and template_response middleware. This method is everything that happens inside the request/response middleware. \u0026#34;\u0026#34;\u0026#34; response = None # 核心内容 callback, callback_args, callback_kwargs = self.resolve_request(request) # Apply view middleware for middleware_method in self._view_middleware: response = middleware_method( request, callback, callback_args, callback_kwargs ) if response: break if response is None: wrapped_callback = self.make_view_atomic(callback) # If it is an asynchronous view, run it in a subthread. if asyncio.iscoroutinefunction(wrapped_callback): wrapped_callback = async_to_sync(wrapped_callback) try: # 自定义的视图函数处理 WSGIRequest对象 response = wrapped_callback(request, *callback_args, **callback_kwargs) except Exception as e: response = self.process_exception_by_middleware(e, request) if response is None: raise ","date":"2023-05-05T00:00:00Z","permalink":"https://sona201.github.io/posts/django-middleware/","title":"django middleware"},{"content":"启动命令\n1 python3 manage.py runserver 0.0.0.0:8000 平时用的命令就是这个, 入口是 manage.py 文件\nmanage.py 管理入口文件 1 2 3 4 5 6 7 8 9 10 11 12 def main(): \u0026#34;\u0026#34;\u0026#34;Run administrative tasks.\u0026#34;\u0026#34;\u0026#34; os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;firstDjango.settings\u0026#39;) try: from django.core.management import execute_from_command_line except ImportError as exc: raise ImportError( \u0026#34;Couldn\u0026#39;t import Django. Are you sure it\u0026#39;s installed and \u0026#34; \u0026#34;available on your PYTHONPATH environment variable? Did you \u0026#34; \u0026#34;forget to activate a virtual environment?\u0026#34; ) from exc execute_from_command_line(sys.argv) manage.py 先配置环境变量, 执行命令后会把参数 runserver 0.0.0.0:8000 作为系统参数传给函数 execute_from_command_line\nsite-packages/django/core/management/init.py 1 2 3 4 def execute_from_command_line(argv=None): \u0026#34;\u0026#34;\u0026#34;Run a ManagementUtility.\u0026#34;\u0026#34;\u0026#34; utility = ManagementUtility(argv) utility.execute() 该函数仅仅是处理命令的方法, 实际做的就是实例化 ManagementUtility() , 调用实例的 execute() 方法 ManagementUtility 和 execute_from_command_line 都在 management 的 init 下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def execute(self): \u0026#34;\u0026#34;\u0026#34; Given the command-line arguments, figure out which subcommand is being run, create a parser appropriate to that command, and run it. \u0026#34;\u0026#34;\u0026#34; try: subcommand = self.argv[1] except IndexError: subcommand = \u0026#34;help\u0026#34; # Display help if no arguments were given. # Preprocess options to extract --settings and --pythonpath. # These options could affect the commands that are available, so they # must be processed early. parser = CommandParser( prog=self.prog_name, usage=\u0026#34;%(prog)s subcommand [options] [args]\u0026#34;, add_help=False, allow_abbrev=False, ) parser.add_argument(\u0026#34;--settings\u0026#34;) parser.add_argument(\u0026#34;--pythonpath\u0026#34;) parser.add_argument(\u0026#34;args\u0026#34;, nargs=\u0026#34;*\u0026#34;) # catch-all try: options, args = parser.parse_known_args(self.argv[2:]) handle_default_options(options) except CommandError: pass # Ignore any option errors at this point. try: settings.INSTALLED_APPS except ImproperlyConfigured as exc: self.settings_exception = exc except ImportError as exc: self.settings_exception = exc if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can\u0026#39;t rely on a # flag on the command class because we haven\u0026#39;t located it yet. if subcommand == \u0026#34;runserver\u0026#34; and \u0026#34;--noreload\u0026#34; not in self.argv: try: autoreload.check_errors(django.setup)() except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn\u0026#39;t happen by # loading an empty list of applications. apps.all_models = defaultdict(dict) apps.app_configs = {} apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles\u0026#39; runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command(\u0026#34;runserver\u0026#34;).create_parser( \u0026#34;django\u0026#34;, \u0026#34;runserver\u0026#34; ) _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() self.autocomplete() if subcommand == \u0026#34;help\u0026#34;: if \u0026#34;--commands\u0026#34; in args: sys.stdout.write(self.main_help_text(commands_only=True) + \u0026#34;\\n\u0026#34;) elif not options.args: sys.stdout.write(self.main_help_text() + \u0026#34;\\n\u0026#34;) else: self.fetch_command(options.args[0]).print_help( self.prog_name, options.args[0] ) # Special-cases: We want \u0026#39;django-admin --version\u0026#39; and # \u0026#39;django-admin --help\u0026#39; to work, for backwards compatibility. elif subcommand == \u0026#34;version\u0026#34; or self.argv[1:] == [\u0026#34;--version\u0026#34;]: sys.stdout.write(django.get_version() + \u0026#34;\\n\u0026#34;) elif self.argv[1:] in ([\u0026#34;--help\u0026#34;], [\u0026#34;-h\u0026#34;]): sys.stdout.write(self.main_help_text() + \u0026#34;\\n\u0026#34;) else: self.fetch_command(subcommand).run_from_argv(self.argv) 截取了 ManagementUtility 的 execute 方法代码 这个就是 CommandParser 对命令的解析, 优先加载django的配置 最重要的是最后一句 self.fetch_command(subcommand).Command(self.argv) 执行 fetch_command(subcommand) 得到了 \u0026lsquo;django.contrib.staticfiles.management.commands.runserver\u0026rsquo; 结果 对应的文件路径: site-packages/django/contrib/staticfiles/management/commands/runserver.py\nsite-packages/django/core/management/commands/runserver.py 执行函数导入\n1 2 3 4 5 6 7 8 def load_command_class(app_name, name): \u0026#34;\u0026#34;\u0026#34; Given a command name and an application name, return the Command class instance. Allow all errors raised by the import process (ImportError, AttributeError) to propagate. \u0026#34;\u0026#34;\u0026#34; module = import_module(\u0026#34;%s.management.commands.%s\u0026#34; % (app_name, name)) return module.Command() 即将 command 模块导入 然后实例化 django.contrib.staticfiles.management.commands.runserver.Command() 所有的命令方法都是有 command 类\n这个函数就是获取对应文件名, 然后导入Command类, 执行 run_from_argv 方法\ndjango.contrib.staticfiles.management.commands.runserver 中没有 run_from_argv 方法 django.core.management.commands.runserver 中也没有 run_from_argv 方法 django.core.management.base.BaseCommand 中有 run_from_argv 方法 主要是执行 self.execute 方法\ndjango.core.management.commands.runserver 的execute方法\n1 2 3 4 5 6 7 def execute(self, *args, **options): if options[\u0026#34;no_color\u0026#34;]: # We rely on the environment because it\u0026#39;s currently the only # way to reach WSGIRequestHandler. This seems an acceptable # compromise considering `runserver` runs indefinitely. os.environ[\u0026#34;DJANGO_COLORS\u0026#34;] = \u0026#34;nocolor\u0026#34; super().execute(*args, **options) django.core.management.base.BaseCommand 的execute 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def execute(self, *args, **options): \u0026#34;\u0026#34;\u0026#34; Try to execute this command, performing system checks if needed (as controlled by the ``requires_system_checks`` attribute, except if force-skipped). \u0026#34;\u0026#34;\u0026#34; if options[\u0026#34;force_color\u0026#34;] and options[\u0026#34;no_color\u0026#34;]: raise CommandError( \u0026#34;The --no-color and --force-color options can\u0026#39;t be used together.\u0026#34; ) if options[\u0026#34;force_color\u0026#34;]: self.style = color_style(force_color=True) elif options[\u0026#34;no_color\u0026#34;]: self.style = no_style() self.stderr.style_func = None if options.get(\u0026#34;stdout\u0026#34;): self.stdout = OutputWrapper(options[\u0026#34;stdout\u0026#34;]) if options.get(\u0026#34;stderr\u0026#34;): self.stderr = OutputWrapper(options[\u0026#34;stderr\u0026#34;]) if self.requires_system_checks and not options[\u0026#34;skip_checks\u0026#34;]: if self.requires_system_checks == ALL_CHECKS: self.check() else: self.check(tags=self.requires_system_checks) if self.requires_migrations_checks: self.check_migrations() output = self.handle(*args, **options) if output: if self.output_transaction: connection = connections[options.get(\u0026#34;database\u0026#34;, DEFAULT_DB_ALIAS)] output = \u0026#34;%s\\n%s\\n%s\u0026#34; % ( self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()), output, self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()), ) self.stdout.write(output) return output 执行 self.handle 方法 django.core.management.commands.runserver 的 handle 方法\ndjango.core.management.commands.runserver 的 run 方法 django.core.management.commands.runserver 的 inner_run 方法\n1 2 3 4 5 6 7 8 9 handler = self.get_handler(*args, **options) run( self.addr, int(self.port), handler, ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls, ) runserver 最终执行逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): # django WSGIServer server_address = (addr, port) # httpd_cls = WSGIServer if threading: httpd_cls = type(\u0026#34;WSGIServer\u0026#34;, (socketserver.ThreadingMixIn, server_cls), {}) else: httpd_cls = server_cls # httpd = WSGIServer((\u0026#39;0.0.0.0\u0026#39;, 8000), WSGIRequestHandler, ipv6=False) httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: # ThreadingMixIn.daemon_threads indicates how threads will behave on an # abrupt shutdown; like quitting the server by the user or restarting # by the auto-reloader. True means the server will not wait for thread # termination before it quits. This will make auto-reloader faster # and will prevent the need to kill the server manually if a thread # isn\u0026#39;t terminating correctly. httpd.daemon_threads = True # wsgi_handler 是一个 WSGIHandler 对象, wsgi_handler() httpd.set_app(wsgi_handler) # wsgi_handler 就是请求处理器, 即 func 函数 # /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/socketserver.py # serve_forever 方法是继承 socketserver.BaseServer.serve_forever() httpd.serve_forever() run 方法 与 wsgiref封装的模型中的 make_server 很相似 表面上都是实例化一个叫 WSGIServer 的类, 然后执行实例的 serve_forever 方法(这个方法是通过多层继承 BaseServer 类的方法, 乃 python 原生方法) 但django run 中 WSGIServer 与 make_server 中 WSGIServer 不是同一个类\n1 2 3 4 5 6 7 def make_server( host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler ): \u0026#34;\u0026#34;\u0026#34;Create a new WSGI server listening on `host` and `port` for `app`\u0026#34;\u0026#34;\u0026#34; server = server_class((host, port), handler_class) server.set_app(app) return server 在 wsgiref封装的模型中, WSGIServer 是使用 simple_server.WSGIServer 这个类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WSGIServer(HTTPServer): \u0026#34;\u0026#34;\u0026#34;BaseHTTPServer that implements the Python WSGI protocol\u0026#34;\u0026#34;\u0026#34; application = None def server_bind(self): \u0026#34;\u0026#34;\u0026#34;Override server_bind to store the server name.\u0026#34;\u0026#34;\u0026#34; HTTPServer.server_bind(self) self.setup_environ() def setup_environ(self): # Set up base environment env = self.base_environ = {} env[\u0026#39;SERVER_NAME\u0026#39;] = self.server_name env[\u0026#39;GATEWAY_INTERFACE\u0026#39;] = \u0026#39;CGI/1.1\u0026#39; env[\u0026#39;SERVER_PORT\u0026#39;] = str(self.server_port) env[\u0026#39;REMOTE_HOST\u0026#39;]=\u0026#39;\u0026#39; env[\u0026#39;CONTENT_LENGTH\u0026#39;]=\u0026#39;\u0026#39; env[\u0026#39;SCRIPT_NAME\u0026#39;] = \u0026#39;\u0026#39; def get_app(self): return self.application def set_app(self,application): self.application = application Django 中 run 方法中的 WSGIServer 继承了 simple_server.WSGIServer 增加了一些错误处理, 本质上其实一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class WSGIServer(simple_server.WSGIServer): \u0026#34;\u0026#34;\u0026#34;BaseHTTPServer that implements the Python WSGI protocol\u0026#34;\u0026#34;\u0026#34; request_queue_size = 10 def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs): if ipv6: self.address_family = socket.AF_INET6 self.allow_reuse_address = allow_reuse_address super().__init__(*args, **kwargs) def handle_error(self, request, client_address): if is_broken_pipe_error(): logger.info(\u0026#34;- Broken pipe from %s\\n\u0026#34;, client_address) else: super().handle_error(request, client_address) runserver 最终执行逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer): # django WSGIServer server_address = (addr, port) # httpd_cls = WSGIServer if threading: httpd_cls = type(\u0026#34;WSGIServer\u0026#34;, (socketserver.ThreadingMixIn, server_cls), {}) else: httpd_cls = server_cls # httpd = WSGIServer((\u0026#39;0.0.0.0\u0026#39;, 8000), WSGIRequestHandler, ipv6=False) httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: httpd.daemon_threads = True # wsgi_handler 是一个 WSGIHandler 对象, wsgi_handler() httpd.set_app(wsgi_handler) # wsgi_handler 就是请求处理器, 返回对应的 func 函数 httpd.serve_forever() handler = self.get_handler(*args, **options) -\u0026gt; get_internal_wsgi_application() -\u0026gt; get_wsgi_application() -\u0026gt; WSGIHandler() handler = WSGIHandler() -\u0026gt; handler(environ, start_response) -\u0026gt; WSGIHandler.call(environ, start_response)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware() def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ) request = self.request_class(environ) response = self.get_response(request) response._handler_class = self.__class__ status = \u0026#34;%d %s\u0026#34; % (response.status_code, response.reason_phrase) response_headers = [ *response.items(), *((\u0026#34;Set-Cookie\u0026#34;, c.output(header=\u0026#34;\u0026#34;)) for c in response.cookies.values()), ] start_response(status, response_headers) if getattr(response, \u0026#34;file_to_stream\u0026#34;, None) is not None and environ.get( \u0026#34;wsgi.file_wrapper\u0026#34; ): # If `wsgi.file_wrapper` is used the WSGI server does not call # .close on the response, but on the file wrapper. Patch it to use # response.close instead which takes care of closing all files. response.file_to_stream.close = response.close response = environ[\u0026#34;wsgi.file_wrapper\u0026#34;]( response.file_to_stream, response.block_size ) return response ","date":"2023-05-05T00:00:00Z","permalink":"https://sona201.github.io/posts/django-runserver/","title":"django runserver"},{"content":"WSGIHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware() def __call__(self, environ, start_response): set_script_prefix(get_script_name(environ)) signals.request_started.send(sender=self.__class__, environ=environ) # WSGIRequest对象 -\u0026gt; HttpRequest类 # def echo(request, *args, **kwargs): # data = request.GET # ret_value = data.get(\u0026#39;name\u0026#39;, \u0026#39;world\u0026#39;) # return HttpResponse(ret_value, content_type=\u0026#39;text/plain\u0026#39;) # 在 app/view/echo 中, 传入的 request 即为当前封装的request_class对象 request = self.request_class(environ) # HttpResponse 类 response = self.get_response(request) response._handler_class = self.__class__ status = \u0026#34;%d %s\u0026#34; % (response.status_code, response.reason_phrase) response_headers = [ *response.items(), *((\u0026#34;Set-Cookie\u0026#34;, c.output(header=\u0026#34;\u0026#34;)) for c in response.cookies.values()), ] start_response(status, response_headers) if getattr(response, \u0026#34;file_to_stream\u0026#34;, None) is not None and environ.get( \u0026#34;wsgi.file_wrapper\u0026#34; ): # If `wsgi.file_wrapper` is used the WSGI server does not call # .close on the response, but on the file wrapper. Patch it to use # response.close instead which takes care of closing all files. response.file_to_stream.close = response.close response = environ[\u0026#34;wsgi.file_wrapper\u0026#34;]( response.file_to_stream, response.block_size ) return response self.get_response(request) 是继承的父类 BaseHandler 的 get_response 方法 site-packages/django/core/handlers/base.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def get_response(self, request): \u0026#34;\u0026#34;\u0026#34;Return an HttpResponse object for the given HttpRequest.\u0026#34;\u0026#34;\u0026#34; # Setup default url resolver for this thread set_urlconf(settings.ROOT_URLCONF) # self._middleware_chain() 是处理的主要逻辑, 包含中间件和自己的视图层处理逻辑 response = self._middleware_chain(request) response._resource_closers.append(request.close) if response.status_code \u0026gt;= 400: log_response( \u0026#34;%s: %s\u0026#34;, response.reason_phrase, request.path, response=response, request=request, ) return response 处理 self._middleware_chain() 逻辑 在 BaseHandler 类的 load_middleware 方法里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class BaseHandler: _view_middleware = None _template_response_middleware = None _exception_middleware = None _middleware_chain = None def load_middleware(self, is_async=False): \u0026#34;\u0026#34;\u0026#34; Populate middleware lists from settings.MIDDLEWARE. Must be called after the environment is fixed (see __call__ in subclasses). \u0026#34;\u0026#34;\u0026#34; self._view_middleware = [] self._template_response_middleware = [] self._exception_middleware = [] # 关键代码 get_response = self._get_response_async if is_async else self._get_response handler = convert_exception_to_response(get_response) handler_is_async = is_async for middleware_path in reversed(settings.MIDDLEWARE): middleware = import_string(middleware_path) middleware_can_sync = getattr(middleware, \u0026#34;sync_capable\u0026#34;, True) middleware_can_async = getattr(middleware, \u0026#34;async_capable\u0026#34;, False) if not middleware_can_sync and not middleware_can_async: raise RuntimeError( \u0026#34;Middleware %s must have at least one of \u0026#34; \u0026#34;sync_capable/async_capable set to True.\u0026#34; % middleware_path ) elif not handler_is_async and middleware_can_sync: middleware_is_async = False else: middleware_is_async = middleware_can_async try: # Adapt handler, if needed. adapted_handler = self.adapt_method_mode( middleware_is_async, handler, handler_is_async, debug=settings.DEBUG, name=\u0026#34;middleware %s\u0026#34; % middleware_path, ) mw_instance = middleware(adapted_handler) except MiddlewareNotUsed as exc: if settings.DEBUG: if str(exc): logger.debug(\u0026#34;MiddlewareNotUsed(%r): %s\u0026#34;, middleware_path, exc) else: logger.debug(\u0026#34;MiddlewareNotUsed: %r\u0026#34;, middleware_path) continue else: handler = adapted_handler if mw_instance is None: raise ImproperlyConfigured( \u0026#34;Middleware factory %s returned None.\u0026#34; % middleware_path ) if hasattr(mw_instance, \u0026#34;process_view\u0026#34;): self._view_middleware.insert( 0, self.adapt_method_mode(is_async, mw_instance.process_view), ) if hasattr(mw_instance, \u0026#34;process_template_response\u0026#34;): self._template_response_middleware.append( self.adapt_method_mode( is_async, mw_instance.process_template_response ), ) if hasattr(mw_instance, \u0026#34;process_exception\u0026#34;): # The exception-handling stack is still always synchronous for # now, so adapt that way. self._exception_middleware.append( self.adapt_method_mode(False, mw_instance.process_exception), ) handler = convert_exception_to_response(mw_instance) handler_is_async = middleware_is_async # Adapt the top of the stack, if needed. handler = self.adapt_method_mode(is_async, handler, handler_is_async) # We only assign to this when initialization is complete as it is used # as a flag for initialization being complete. self._middleware_chain = handler 在 WSGIHandler 初始化 init 的时候, 就执行了 self.load_middleware() 方法\n1 2 3 4 5 6 class WSGIHandler(base.BaseHandler): request_class = WSGIRequest def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.load_middleware() django 服务器起来后, 请求进来 实例化 WSGIHandler() ,执行 load_middleware, 得到 HttpResponse 对象\n","date":"2023-05-05T00:00:00Z","permalink":"https://sona201.github.io/posts/django-wsgihandler/","title":"django WSGIHandler"},{"content":"django 封装模型采用 wsgiref 模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from wsgiref.simple_server import make_server def routers(): # URLConf 配置 urlpatterns = ( (\u0026#39;/book\u0026#39;, foo), (\u0026#39;/web\u0026#39;, bar), ) return urlpatterns def foo(x): return [b\u0026#39;\u0026lt;h1\u0026gt;Hello, book\u0026lt;/h1\u0026gt;\u0026#39;] def bar(x): return [b\u0026#39;\u0026lt;h1\u0026gt;Hello, web\u0026lt;/h1\u0026gt;\u0026#39;] def application(environ, start_response): start_response(\u0026#39;200 OK\u0026#39;, [(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html\u0026#39;)]) urlpatterns = routers() path = environ[\u0026#39;PATH_INFO\u0026#39;] # http://127.0.0.1:8000/book func = None for item in urlpatterns: if item[0] == path: func = item[1] break if func: return func(environ) else: return [\u0026#39;\u0026lt;h1\u0026gt;404\u0026lt;/h1\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)] httpd = make_server(\u0026#39;127.0.0.1\u0026#39;, 8000, application) print(\u0026#39;Serving HTTP on port 8000...\u0026#39;) httpd.serve_forever() 这里启动了一个server, 做了一个路由分发, 函数处理\n","date":"2023-05-05T00:00:00Z","permalink":"https://sona201.github.io/posts/django-wsgiref/","title":"django wsgiref"},{"content":"django 封装模型采用 wsgiref 模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from wsgiref.simple_server import make_server def routers(): # URLConf 配置 urlpatterns = ( (\u0026#39;/book\u0026#39;, foo), (\u0026#39;/web\u0026#39;, bar), ) return urlpatterns def foo(x): return [b\u0026#39;\u0026lt;h1\u0026gt;Hello, book\u0026lt;/h1\u0026gt;\u0026#39;] def bar(x): return [b\u0026#39;\u0026lt;h1\u0026gt;Hello, web\u0026lt;/h1\u0026gt;\u0026#39;] def application(environ, start_response): start_response(\u0026#39;200 OK\u0026#39;, [(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html\u0026#39;)]) urlpatterns = routers() path = environ[\u0026#39;PATH_INFO\u0026#39;] # http://127.0.0.1:8000/book func = None for item in urlpatterns: if item[0] == path: func = item[1] break if func: return func(environ) else: return [\u0026#39;\u0026lt;h1\u0026gt;404\u0026lt;/h1\u0026gt;\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)] httpd = make_server(\u0026#39;127.0.0.1\u0026#39;, 8000, application) print(\u0026#39;Serving HTTP on port 8000...\u0026#39;) httpd.serve_forever() 这里启动了一个server, 做了一个路由分发, 函数处理\n","date":"2023-05-05T00:00:00Z","permalink":"https://sona201.github.io/posts/wsgiref/","title":"Wsgiref"},{"content":"抓包: 两台服务器，一台启动python http服务，上面有一个2G的文件。另一台下载。 怎么抓包，在那台机器上抓包，是不是指定来源ip就可以了？ 是指定抓n个包，还是说指定ip，从开始下载到结束？ 抓完包后怎么分析，需要分析哪些内容？arp协议？地址询问？http三次握手？三次挥手？ 怎么调整内核，又要重新抓包？内核调整时，服务器有什么变化，用top命令能看出来么？ rt，丢包率，curl速度怎么查看？使用\u0026ndash;help，需要谷歌协助么？ 执行curl就出问题了\n服务端\n1 2 3 4 5 server:172.19.5.43 python -m SimpleHTTPServer 8089 ll -h -rw-r--r--. 1 root root 1.9G Mar 25 11:37 zookeeper.out 客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 client:172.19.9.147 tcpdump -i eth0 tcp port 8089 and host 172.19.5.43 -w tcpdump-$(date +%Y-%m-%d-%H-%M-%S).cap [root@172.19.9.147 ~]# wget http://172.19.5.43:8089/zookeeper.out --2023-03-26 00:49:47-- http://172.19.5.43:8089/zookeeper.out Connecting to 172.19.5.43:8089... connected. HTTP request sent, awaiting response... 200 OK Length: 1972256747 (1.8G) [application/octet-stream] Saving to: ‘zookeeper.out’ 100%[==========================================================================================================================================\u0026gt;] 1,972,256,747 53.2MB/s in 25s 2023-03-26 00:50:11 (76.3 MB/s) - ‘zookeeper.out’ saved [1972256747/1972256747] [root@172.19.9.147 ~]# curl http://172.19.5.43:8089/zookeeper.out --output zookeeper.out.file % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 1880M 100 1880M 0 0 77.0M 0 0:00:24 0:00:24 --:--:-- 54.3M curl 控制速度\n1 2 3 4 [root@172.19.9.147 ~]# curl http://172.19.5.43:8089/zookeeper.out --output zookeeper.out.file --limit-rate 1M % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 33 1880M 33 625M 0 0 1023k 0 0:31:21 0:10:25 0:20:56 996k tc命令介绍\nBDP和buffer、RT的关系 搜这个问题发现别人早就看过任总的文章了，还写了笔记。https://blog.csdn.net/fdsafwagdagadg6576/article/details/121011575\n相关概念\nBDP: (Bandwidth-Delay Product) 带宽时延积 Buffer: 指的是sysctl中的 rmem或者wmem rt: tcp的timestamps-\u0026gt;time since previous frame in this tcp stream(我猜就是响应时间的一种) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@172.19.5.43 ~]# sysctl -a | grep \u0026#39;net.ipv4.tcp_wmem\u0026#39; sysctl: reading key \u0026#34;net.ipv6.conf.all.stable_secret\u0026#34; net.ipv4.tcp_wmem = 4096 16384 4194304 sysctl: reading key \u0026#34;net.ipv6.conf.default.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.docker0.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.eth0.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.lo.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.veth59705c1.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.veth6cbfe80.stable_secret\u0026#34; [root@172.19.5.43 ~]# sysctl -a | grep \u0026#39;net.ipv4.tcp_wmem\u0026#39; sysctl: reading key \u0026#34;net.ipv6.conf.all.stable_secret\u0026#34; net.ipv4.tcp_wmem = 4096 4096 4096 sysctl: reading key \u0026#34;net.ipv6.conf.default.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.docker0.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.eth0.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.lo.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.veth59705c1.stable_secret\u0026#34; sysctl: reading key \u0026#34;net.ipv6.conf.veth6cbfe80.stable_secret\u0026#34; 参数相关\n更新了配置后，直接服务也启动失败，wget也异常了。\n","date":"2023-05-05T01:05:14+08:00","permalink":"https://sona201.github.io/posts/tcp%E5%AE%9E%E9%AA%8C/","title":"tcp实验"},{"content":"博客搭建 最早博客搭建是用的wordpress，挑了好久(就是拖延)，最后选了hugo，说是快。因为看到很多人从hexo转hugo，想一步到位。其实可能并不能写太多文章发布 自己也测试了hexo，体验了一把，确实感觉速度慢，不能接受(虽然时间没那么宝贵，但有点耗神)\n记录下操作记录吧，方便后期回顾\n最开始也想用自己的域名，但在申请域名的时候难倒了，纠结于名字，最后决定，快速上线，先用 github.io 这个\n博客搭建最靠谱的方案\ngit action https://www.pseudoyu.com/zh/2022/05/29/deploy_your_blog_using_hugo_and_github_action/\n最后就是hugo的使用，跟主题修改了，现在还没做好，慢慢改\n是否需要英文版面 决定有哪几个大分类 [-] 评论系统 最后就是样式优化，参考: https://blog.skk.moe/ 差不多就是这些，特比担心三分钟热的，甚至不足三分钟。先记录下来\nhttps://io-oi.me/tech/hugo-vs-hexo/\nhttps://hexo.io/zh-cn/\nhttps://blog.skk.moe/post/use-nextjs-and-hexo-to-rebuild-my-blog/\nhttps://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#%E5%9B%9B%E9%80%89%E6%8B%A9-hugo-%E4%B8%BB%E9%A2%98\nhttps://www.sulvblog.cn/posts/blog/shortcodes/\nhttps://zhuanlan.zhihu.com/p/126298572\nhttps://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/\nhttps://zzzqiii.github.io/p/%E6%9B%B4%E6%96%B0hugo%E4%B8%BB%E9%A2%98/\nhttps://blog.gezi.men/p/hugo-theme-stack-configuration/ https://blog.zhixuan.dev/posts/ac760353/\nhttps://www.google.com/search?q=hugo+%E4%B8%BB%E9%A2%98+stack+%E6%9B%B4%E6%96%B0\u0026oq=hugo+%E4%B8%BB%E9%A2%98+stack+%E6%9B%B4%E6%96%B0\u0026aqs=chrome..69i57j33i10i160.11218j0j1\u0026sourceid=chrome\u0026ie=UTF-8\n\u0026mdash;-搭建初始，发布文章操作 https://jinli.cyou/p/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%E4%B8%89hugo%E4%B8%BB%E9%A2%98stack%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/\n发布文章配置操作 https://olowolo.com/post/hugo-quick-start/ 模板配置操作 Hugo 详细笔记（建站教程、工作原理）\nhttps://chupai.github.io/posts/200316_hugo/\nhttps://www.gohugo.org/doc/overview/quickstart/\nhttps://www.gohugo.org/doc/content/organization/\nhttps://shuzang.github.io/2019/hugo-blog-article-write/\nhugo 的配置使用 https://www.yunduan.io/posts/hugo-medium-level-lesson/\ncloudflare deployment\nhttps://developers.cloudflare.com/pages/framework-guides/deploy-a-hugo-site/\nhttps://gohugo.io/hosting-and-deployment/hosting-on-github/\n好的链接 https://strrl.dev/links/\n博客搭建最靠谱的方案 https://www.pseudoyu.com/zh/2022/06/12/why_i_still_write_blog_in_2022/\n子模块功能 git submodule add https://github.com/sona201/hugo-theme-stack themes/hugo-theme-stack\nhttps://github.com/peaceiris/actions-hugo\nGit submodule 子模块的管理和使用 Git submodule简书 Git submodule git-scm\n博客安装 1 2 3 4 5 6 7 arch -arm64 brew install hugo brew install hugo git clone https://github.com/sona201/blogs.git git submodule git submodule init git submodule update hugo 配置讲解\n路径配置最关键\n最新部署\n主题搭建参考链接https://www.jianshu.com/p/0b9aecff290c\n这个链接配置是从零开始，最后搭建出一个样式，但里面教你操作的配置是toml文件，但似乎用的是yaml文件，这个需要了解下。\n在使用toml配置方式启动时，报错\n1 2 WARN 2023/05/26 13:59:29 found no layout file for \u0026#34;JSON\u0026#34; for layout \u0026#34;search\u0026#34; for kind \u0026#34;page\u0026#34;: You should create a template file which matches Hugo Layouts Lookup Rules for this combination. Rebuilt in 47 ms 这个后面也要看看是什么问题。\nhttps://qwqaq.com/2022/04/migrate-to-hugo/#%E5%88%B6%E4%BD%9C%E4%B8%BB%E9%A2%98\n这个链接讲内容很详细，但没有讲怎么搞配置文件。所以要结合上面一篇文章\n关于博客搭建(建站之初link)\nhttps://blog.kermsite.com/p/hugostack%E4%B8%BB%E9%A2%98 https://stack-theme-mod.vercel.app/2022/stack-theme-mod/ https://stack.jimmycai.com/guide/modify-theme https://viflythink.com/Migrate_from_Material_to_Stack/ https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/ https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%971/ https://xrg.fj.cn/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%972/ https://viflythink.com/links/ ","date":"2023-04-09T13:51:52+08:00","permalink":"https://sona201.github.io/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"},{"content":"hugo\n使用文档: https://gohugo.io/documentation/\n主题配置：https://stack.jimmycai.com/\n从入门到放弃： https://olowolo.com/post/hugo-quick-start/\n研究分类布局 https://github.com/olOwOlo/hugo-theme-even/blob/master/exampleSite/config.toml\nhttps://olowolo.com/post/hugo-quick-start/\nhttps://jinli.cyou/p/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%E4%B8%89hugo%E4%B8%BB%E9%A2%98stack%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/\n","date":"2022-11-14T00:34:58+08:00","permalink":"https://sona201.github.io/posts/hugo-framework/","title":"Hugo Framework"}]